<!DOCTYPE html>
<meta charset="utf-8">
  <title>Visualization of Iraqi Asylum Seekers</title>
  <head>
    <style >
      svg {background-color: #FEF5E7;}
    </style>
  </head>

  <body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
    /* code based on various internet sources, including:
    https://flowingdata.com/2016/08/23/make-a-moving-bubbles-chart-to-show-clustering-and-distributions/
    https://bl.ocks.org/pbogden/854425acb57b4e5a4fdf4242c068a127
    */
d3.json("irq_asy_de.json", function (error, data) {
        var dataset;
        if (error) {
            console.log(error);
        } else {
            dataset = data;
            console.log(data);
        }

        var margin = { top: 16, right: 0, bottom: 0, left: 0 },
            width = 950 - margin.left - margin.right,
            height = 700 - margin.top - margin.bottom;

        var radius = 5;


        // Foci: where the nodes will go and their color
        var clusters = {
            "seekers": { x: 475, y: 250, color: "#283747" },
            "recognized": { x: 225, y: 500, color: "#1E8449" },
            "rejected": { x: 525, y: 500, color: "#E74C3C" },
            "other": { x: 725, y: 500, color: "#5DADE2" },
        };


        // Nodes for each group
        var n = Math.round(dataset[0].Total_apps / 1000); // total number of circles
        var recognized = Math.round(dataset[0].Recognized / 1000);
        var rejected = Math.round(dataset[0].Rejected / 1000);
        var other = Math.round(dataset[0].Other / 1000);

        // to precode where each node is to go
        function preClassify(id) {
            if (id <= recognized) {
                return 'recognized';
            } else if (id > recognized && id <= recognized + rejected) {
                return 'rejected';
            } else if (id > recognized + rejected && id <= recognized + rejected + other) {
                return 'other';
            } else {
                return 'seekers';
            }
        }

        // Create nodes
        var nodes = d3.range(n).map(function (id) {
            var cluster = clusters["seekers"];  //everyone starts out as seekers
            var futureCluster = clusters[preClassify(id)];
            var node = {
                id: id,
                cluster: cluster,
                futureCluster: futureCluster,
                x: cluster.x + Math.random(),
                y: cluster.y + Math.random(),
                radius: radius
            };
            return node;
        });


        // So that the nodes' categories are shuffled 
        nodes = shuffle(nodes);

        // Create svg
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("fill", function (d) {
                return '#abcdef';
            })
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        // Add the nodes
        var circle = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("r", function (d) {
                return d.radius;
            })
            .style("fill", function (d) {
                return d.cluster.color;
            });


        // Prevent collisions between nodes
        var forceCollide = d3.forceCollide()
            .radius(function (d) {
                return d.radius + 2;
            });


        // Force-directed layout
        var simulation = d3.forceSimulation(nodes)
            .force("collide", forceCollide)
            .force("cluster", forceCluster)
            .on("tick", tick);

        // Titles
        var seek = svg.append('text')
            .attr('transform', 'translate(475, 190)')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', 20)
            .style('font-family', "garamond")
            .style('font-weight', 'bold')
            .text('Number of Iraqi Asylum Seekers to ' + dataset[0].Destination + ' in ' + dataset[0].Year);

        var recognize = svg.append('text')
            .attr('transform', 'translate(225, 630)')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', 20)
            .style('font-family', "garamond")
            .text('Recognized');

        var reject = svg.append('text')
            .attr('transform', 'translate(525, 630)')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', 20)
            .style('font-family', "garamond")
            .text('Rejected');

        var other = svg.append('text')
            .attr('transform', 'translate(725,  630)')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', 20)
            .style('font-family', "garamond")
            .text('Other outcome');

        var ast = svg.append('text')
            .attr('transform', 'translate(' + width / 2 + ', 675)')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', 15)
            .style('font-family', "garamond")
            .text('* Each dot represents 1000 asylum seekers');

        // Update frame of animation: redraw in the new position in new color with each tick
        function tick() {
            circle
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                })
                .style("fill", function (d) {
                    return d.cluster.color;
                });
        }


        // Change the x, y velocity for each node
        function forceCluster(alpha) {
            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i];
                node.vx -= (node.x - node.cluster.x) * alpha;
                node.vy -= (node.y - node.cluster.y) * alpha;
            }
        }

        var pending = nodes.slice(); // Copu to pop since pending will be the ones not selected to move

        function classify() {
            if (pending.length > 0) {
                var node = pending.pop();
                node.cluster = node.futureCluster;
            }
            simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
            setTimeout(classify, 100);  // Call itself again .1 second later
        }

        setTimeout(classify, 1000);
    });


    // from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
        return array;
        
    }

  
  </script>