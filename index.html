<!DOCTYPE html>
<meta charset="utf-8">
<title>Visualization of Iraqi Asylum Seekers</title>
<head>
    <style>
        svg {
            background-color: #FEF5E7;
        }
    </style>
</head>

<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    // code based on various internet sources, including:
    // https://flowingdata.com/2016/08/23/make-a-moving-bubbles-chart-to-show-clustering-and-distributions/
    // https://bl.ocks.org/pbogden/854425acb57b4e5a4fdf4242c068a127

    d3.json("irq_14_js.json", function (error, data) {
        var dataset;
        if (error) {
            console.log(error);
        } else {
            dataset = data;
            console.log(data);
        }

        // Global vars
        var margin = { top: 10, right: 10, bottom: 10, left: 10 },
            width = 1000 - margin.left - margin.right,
            height = 1000 - margin.top - margin.bottom;

        var center = {
            x: width /2,
            y: height /2
        };

        var radius = 3;
        var initialCenterClusterRadius = 30;
        var destinationClusterRingRadius = 250;

        var results = {
            "recognized": { x: 0, y: 0, color: "#1E8449" },
            "rejected": { x: 0, y: 0, color: "#E74C3C" },
            "other": { x: 0, y: 0, color: "#5DADE2" }
        };

        // Create svg
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        // Create destination ring around the center with angles -> radians -> coordinates
        var destinationClusters = {
            "Sweden": { theta: - 150 - 30, color: "#ffc3a0"},
            "Germany": { theta: -150 + 30, color: "#ff4444" },

            "Jordan": { theta: - 30 - 30, color: "#ffb14c" },
            "Turkey": { theta: - 30 + 30, color: "#ff9000" },

            "US": { theta: 90 + 40, color: "#ad4b25" },
            "Canada": { theta: 90 - 40, color: "#ad8f25" },
            "World-Elsewhere": { theta: 90, color: "#7161ef" }
        };

        Object.keys(destinationClusters).forEach(function (key) {
            var cluster = destinationClusters[key];
            var radianTheta = (Math.PI / 180) * cluster.theta ;
            cluster.x = destinationClusterRingRadius * Math.cos(radianTheta) + center.x;
            cluster.y = destinationClusterRingRadius * Math.sin(radianTheta) + center.y;

            // Create destination label
            createText(key, cluster.x, cluster.y - 15);
        });

        console.log(destinationClusters)
        
        // Preclassify where each node is to go
        function classify(id, destinationClusters) {
            var recognized = destinationClusters.recognized;
            var rejected = destinationClusters.rejected;
            var other = destinationClusters.other;

            if (id <= recognized) {
                return 'recognized';
            } else if (id > recognized && id <= recognized + rejected) {
                return 'rejected';
            } else if (id > recognized + rejected && id <= recognized + rejected + other) {
                return 'other';
            }
        }


        var nodes = [];
        var centerSeekers = [];
        var pendings = [];

        // Create nodes based on the dataset
        dataset.forEach(function (d) {
            var destinationCluster = destinationClusters[d.Destination];

            // Calculate number of nodes for each classification of the cluster.
            destinationCluster.total = Math.round(d.Total_apps / 1000);
            destinationCluster.recognized = Math.round(d.Recognized / 1000);
            destinationCluster.rejected = Math.round(d.Rejected / 1000);
            destinationCluster.other = Math.round(d.Other / 1000);

            // Create nodes for this destination
            d3.range(destinationCluster.total).map(function (id) {
                var node = {
                    id: d.Destination + id,
                    // Randomize distribution around the center 
                    x: center.x + (initialCenterClusterRadius * (Math.random() * 2 -1)),
                    y: center.y + (initialCenterClusterRadius * (Math.random() * 2 -1)),
                    radius: radius,
                    destinationCluster: destinationCluster,
                    // Classify the nodes in this destination
                    classification: classify(id, destinationCluster),
                    color: "#283747"
                };
                nodes.push(node);
                centerSeekers.push(node);
            });   
        }); 

        console.log(nodes)

        // So that the nodes move randomly  
        centerSeekers = shuffle(centerSeekers);

        console.log(centerSeekers)

        // function from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
        function shuffle(array) {
            var currentIndex = array.length, temporaryValue, randomIndex;
            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;
                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
            return array;
        }

        // Add the nodes
        var circle = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("r", function (d) {
                return d.radius;
            })
            .style("fill", function (d) {
                return d.color;
            });

        // Prevent collisions between nodes
        var forceCollide = d3.forceCollide()
            .radius(function (d) {
                return d.radius + 2;
            });

        // Force-directed layout
        var simulation = d3.forceSimulation(nodes)
            .force("collide", forceCollide)
            .force("cluster", forceCluster)
            .on("tick", tick);

        // Update frame of animation: redraw in the new position in new color with each tick
        function tick() {
            circle
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                })
                .style("fill", function (d) {
                    return d.color;
                });
        }

        // Change the x, y velocity for each node
        function forceCluster(alpha) {
            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i]
                var target = node.target || center;
                node.vx -= (node.x - target.x) * alpha;
                node.vy -= (node.y - target.y) * alpha;
            }
        }

        function goToDestination() {
            if (centerSeekers.length > 0) {
                var node = centerSeekers.pop();
                node.color = node.destinationCluster.color;                
                node.target = node.destinationCluster;
                pendings.push(node) 

                simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
                setTimeout(goToDestination, 100);  // Call itself again .1 second later
            } else {
                setTimeout(classifyPendings, 1000); // Once all at destination (as pending), classify into results category
            }
        }

        setTimeout(goToDestination, 1000);

        // Next level of classification into results groups
        function classifyPendings() {
            if (pendings.length > 0) {
                var node = pendings.pop();
                var classification = results[node.classification];

                if (classification) {
                    node.color = results[node.classification].color;

                    // Clone the current target
                    node.target = { x: node.target.x, y: node.target.y };

                    var classificationOffset = 125;

                    // Assign new locations relative to the current destination's center depending on the classification.
                    if (node.classification === 'recognized') {
                        var radianTheta = (Math.PI / 180) * (node.destinationCluster.theta - 10);
                        node.target = {x: (destinationClusterRingRadius + classificationOffset) * Math.cos(radianTheta) + center.x, 
                            y: (destinationClusterRingRadius + classificationOffset) * Math.sin(radianTheta) + center.y}
                    } else if (node.classification === 'rejected') {
                        var radianTheta = (Math.PI / 180) * node.destinationCluster.theta;
                        node.target = {x: (destinationClusterRingRadius + classificationOffset) * Math.cos(radianTheta) + center.x, 
                            y: (destinationClusterRingRadius + classificationOffset) * Math.sin(radianTheta) + center.y}
                    } else {
                        var radianTheta = (Math.PI / 180) * (node.destinationCluster.theta + 10);
                        node.target = {x: (destinationClusterRingRadius + classificationOffset) * Math.cos(radianTheta) + center.x, 
                            y: (destinationClusterRingRadius + classificationOffset) * Math.sin(radianTheta) + center.y}
                    }
                }


            



                simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
                setTimeout(classifyPendings, 100);  // Call itself again .1 second later
            } else {
                var keepAlive = setInterval(function () {
                    simulation.alpha(0.015);
                }, 100);

                // Keep the nodes moving for another 5 seconds
                setTimeout(function () {
                    clearInterval(keepAlive);
                }, 5000);
            }
        }

        // Create texts
        createText("Seekers", center.x, center.y - 20);
        createText('* Each dot represents 1000 asylum seekers', width/2, height - 30)
                
        function createText(text, x, y) {
            var translate = 'translate(' + x + ', ' + y + ')';
            var text = svg.append('text')
                .attr('transform', translate)
                .style('text-anchor', 'middle')
                .style('fill', 'black')
                .attr('dy', '-2.5em')
                .style('font-size', 15)
                .style('font-family', "garamond")
                .style('font-weight', 'bold')
                .text(text);
            return text;
        }

    });

</script>
