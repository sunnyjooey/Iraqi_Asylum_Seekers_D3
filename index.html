<!DOCTYPE html>
<meta charset="utf-8">
<title>Visualization of Iraqi Asylum Seekers</title>
<head>
    <style>
        svg {
            background-color: #FEF5E7;
        }
    </style>
</head>

<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    // code based on various internet sources, including:
    // https://flowingdata.com/2016/08/23/make-a-moving-bubbles-chart-to-show-clustering-and-distributions/
    // https://bl.ocks.org/pbogden/854425acb57b4e5a4fdf4242c068a127

    d3.json("irq_13_js.json", function (error, data) {
        var dataset;
        if (error) {
            console.log(error);
        } else {
            dataset = data;
            console.log(data);
        }

        // Global vars
        var margin = { top: 10, right: 10, bottom: 10, left: 10 },
            width = 1000 - margin.left - margin.right,
            height = 1000 - margin.top - margin.bottom;

        var center = {
            x: width /2,
            y: height /2
        };

        var radius = 2;
        var initialCenterClusterRadius = 30;
        var destinationClusterRingRadius = 250;

        var results = {
            "seekers": { x: center.x, y: center.y, color: "#283747" },
            "recognized": { color: "#1E8449" },
            "rejected": { color: "#E74C3C" },
            "other": { color: "#5DADE2" }
        };

        // Create svg
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("fill", function (d) {
                return '#abcdef';
            })
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        // Create destination ring around the center with angles -> radians -> coordinates
        var destinationClusters = {
            "Sweden": { theta: 270 - 40, color: "#ffc3a0"},
            "Germany": { theta: 270 - 80, color: "#ff4444" },

            "Jordan": { theta: 270 + 40, color: "#ffb14c" },
            "Turkey": { theta: 270 + 80, color: "#ff9000" },

            "US": { theta: 90 + 30, color: "#ad4b25" },
            "Canada": { theta: 90 - 30, color: "#ad8f25" },
            "World-Elsewhere": { theta: 90, color: "#7161ef" }
        };

        Object.keys(destinationClusters).forEach(function (key) {
            var cluster = destinationClusters[key];
            var radianTheta = (2 * Math.PI) * (cluster.theta / 360);
            cluster.x = destinationClusterRingRadius * Math.cos(radianTheta) + center.x;
            cluster.y = destinationClusterRingRadius * Math.sin(radianTheta) + center.y;

            // Create destination label
            createText(key, cluster.x, cluster.y - 25);
        });

        console.log(destinationClusters)
        
        // Preclassify where each node is to go
        function classify(id, destinationClusters) {
            var recognized = destinationClusters.recognized;
            var rejected = destinationClusters.rejected;
            var other = destinationClusters.other;

            if (id <= recognized) {
                return 'recognized';
            } else if (id > recognized && id <= recognized + rejected) {
                return 'rejected';
            } else if (id > recognized + rejected && id <= recognized + rejected + other) {
                return 'other';
            } else {
                return 'seekers';
            }
        }

        var nodes = [];

        // Create nodes based on the dataset
        dataset.forEach(function (d) {
            var destinationCluster = destinationClusters[d.Destination];

            // Calculate number of nodes for each classification of the cluster.
            destinationCluster.total = Math.round(d.Total_apps / 1000);
            destinationCluster.recognized = Math.round(d.Recognized / 1000);
            destinationCluster.rejected = Math.round(d.Rejected / 1000);
            destinationCluster.other = Math.round(d.Other / 1000);

            // Create nodes for this destination
            d3.range(destinationCluster.total).map(function (id) {
                var node = {
                    id: d.Destination + id,
                    // Randomize distribution around the center 
                    x: center.x + (initialCenterClusterRadius * (Math.random() * 2 -1)),
                    y: center.y + (initialCenterClusterRadius * (Math.random() * 2 -1)),
                    radius: radius,
                    destinationCluster: destinationCluster,
                    // Classify the nodes in this destination
                    classification: classify(id, destinationClusters),
                    color: results.seekers.color,
                    status: 'seeker'
                };
                nodes.push(node);
            });   
        }); 

        console.log(nodes)

        // So that the nodes move randomly  
        nodes = shuffle(nodes);

        // function from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
        function shuffle(array) {
            var currentIndex = array.length, temporaryValue, randomIndex;
            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;
                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
            return array;
        }

        // Create texts
        createText("Seekers", center.x, center.y - 25);
                
        function createText(text, x, y) {
            var translate = 'translate(' + x + ', ' + y + ')';
            var text = svg.append('text')
                .attr('transform', translate)
                .style('text-anchor', 'middle')
                .style('fill', 'black')
                .attr('dy', '-2.5em')
                .style('font-size', 10)
                .style('font-family', "garamond")
                .style('font-weight', 'bold')
                .text(text);
            return text;
        }

        // Add the nodes
        var circle = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("r", function (d) {
                return d.radius;
            })
            .style("fill", function (d) {
                return d.color;
            });

        // Prevent collisions between nodes
        var forceCollide = d3.forceCollide()
            .radius(function (d) {
                return d.radius + 2;
            });

        // Force-directed layout
        var simulation = d3.forceSimulation(nodes)
            .force("collide", forceCollide)
            .force("cluster", forceCluster)
            .on("tick", tick);

        // Update frame of animation: redraw in the new position in new color with each tick
        function tick() {
            circle
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                })
                .style("fill", function (d) {
                    return d.color;
                });
        }

        // Change the x, y velocity for each node
        function forceCluster(alpha) {
            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i]
                var target;
                if (node.status === 'seeker') {
                    target = center;
                } else if (node.status === 'pending') {
                    target = node.destinationCluster;
                } else if (node.status === 'classified') {
                    target = node.destinationCluster;
                }
                node.vx -= (node.x - target.x) * alpha;
                node.vy -= (node.y - target.y) * alpha;
            }
        }

        var centerSeekers = nodes.slice(); // Copy to pop since pending will be the ones not selected to move

        function goToDestination() {
            if (centerSeekers.length > 0) {
                var node = centerSeekers.pop();
                node.status = 'pending';
                node.color = node.destinationCluster.color;
            }
            simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
            setTimeout(goToDestination, 100);  // Call itself again .1 second later
        }

        setTimeout(goToDestination, 1000);
    });



    //     // Titles
    //     var seek = svg.append('text')
    //         .attr('transform', 'translate(475, 190)')
    //         .style('text-anchor', 'middle')
    //         .style('fill', 'black')
    //         .attr('dy', '-2.5em')
    //         .style('font-size', 20)
    //         .style('font-family', "garamond")
    //         .style('font-weight', 'bold')
    //         .text('Number of Iraqi Asylum Seekers to ' + dataset[0].Destination + ' in ' + dataset[0].Year);

    //     var recognize = svg.append('text')
    //         .attr('transform', 'translate(225, 630)')
    //         .style('text-anchor', 'middle')
    //         .style('fill', 'black')
    //         .attr('dy', '-2.5em')
    //         .style('font-size', 20)
    //         .style('font-family', "garamond")
    //         .text('Recognized');

    //     var reject = svg.append('text')
    //         .attr('transform', 'translate(525, 630)')
    //         .style('text-anchor', 'middle')
    //         .style('fill', 'black')
    //         .attr('dy', '-2.5em')
    //         .style('font-size', 20)
    //         .style('font-family', "garamond")
    //         .text('Rejected');

    //     var other = svg.append('text')
    //         .attr('transform', 'translate(725,  630)')
    //         .style('text-anchor', 'middle')
    //         .style('fill', 'black')
    //         .attr('dy', '-2.5em')
    //         .style('font-size', 20)
    //         .style('font-family', "garamond")
    //         .text('Other outcome');

    //     var ast = svg.append('text')
    //         .attr('transform', 'translate(' + width / 2 + ', 675)')
    //         .style('text-anchor', 'middle')
    //         .style('fill', 'black')
    //         .attr('dy', '-2.5em')
    //         .style('font-size', 15)
    //         .style('font-family', "garamond")
    //         .text('* Each dot represents 1000 asylum seekers');

    //     
    // }


</script>
