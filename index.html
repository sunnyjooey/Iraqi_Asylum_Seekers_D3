<!DOCTYPE html>
<meta charset="utf-8">
  <title>Visualization of Iraqi Asylum Seekers</title>
  <head>
    <style >
      svg {background-color: #FEF5E7;}
    </style>
  </head>

  <body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
    /* code based on various internet sources, including:
    https://flowingdata.com/2016/08/23/make-a-moving-bubbles-chart-to-show-clustering-and-distributions/
    https://bl.ocks.org/pbogden/854425acb57b4e5a4fdf4242c068a127
    */
    d3.json("irq_asy_de.json", function(error, data) {
      if (error) {
        console.log(error); 
      } else {
        dataset = data; 
        console.log(data);} 
      
    var margin = {top: 20, right: 0, bottom: 0, left: 0},
        width = 950 - margin.left - margin.right,
        height = 700 - margin.top - margin.bottom;
    var radius = 5;

    // Foci: where the nodes will go and their color
    var clusters = {
      "pending": { x: 475, y: 250, color: "#283747" },
      "recognized": { x: 225, y: 500, color: "#1E8449" }, 
      "rejected": { x: 525, y: 500, color: "#E74C3C" },
      "other": { x: 725, y: 500, color: "#5DADE2" },
    };
    // Nodes for each group
    var n = Math.round(dataset[0].Total_apps / 1000); // total number of circles
    var recognized = Math.round(dataset[0].Recognized / 1000);
    var rejected = Math.round(dataset[0].Rejected / 1000);
    var other = Math.round(dataset[0].Other / 1000);
    


    function classify(id) {
        if (id <= recognized) {
            return 'recognized';
        } else if (id > recognized && id <= recognized + rejected) {
            return 'rejected';
        } else if (id > recognized + rejected && id <= recognized + rejected + other) {
            return 'other';
        } else {
            return 'pending';
        };
    } 

    var toBeClassed = [];

    //Create nodes
    var nodes = d3.range(n).map(function(id) {
        var classifiedCluster = classify(id)
        var d = {
            id: id,
            classifiedCluster: clusters[classifiedCluster],
            cluster: clusters['pending'],
            x: clusters['pending'].x + Math.random(),
            y: clusters['pending'].y + Math.random(),
            radius: radius
        };
        if (classifiedCluster !== 'pending') {
        	toBeClassed.push(d);
        }
        return d;
    });

    // // Create svg
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("fill", function(d) { return '#abcdef'; })
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var simulation = d3.forceSimulation(nodes)
          .force('charge', d3.forceManyBody().strength(5))
          .force('x', d3.forceX().x(function(d) {
            return clusters[d.cluster.x];
          }))
          .force('y', d3.forceY().y(function(d) {
            return clusters[d.cluster.y];
          }))
          .force('collision', d3.forceCollide().radius(function(d) {
            return d.radius;
          }))
          .on('tick', ticked);

    function ticked() {
      var u = d3.select('svg g')
        .selectAll('circle')
        .data(nodes);

      u.enter()
        .append('circle')
        .attr('r', function(d) {
          return d.radius;
        })
        .style('fill', function(d) {
          return d.cluster.color;
        })
        .merge(u)
        .attr('cx', function(d) {
          return d.cluster.x;
        })
        .attr('cy', function(d) {
          return d.cluster.y;
        })

      u.exit().remove();
    }

function run() {

	if (toBeClassed.length > 0) {
    	var node = toBeClassed.pop();
    	node.cluster = node.classifiedCluster;
    }
      
      simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
      setTimeout(run, 100);  // Call itself again .1 second later
} 	

    setTimeout(run, 1000);



    // // Add the nodes
    // var circle = svg.selectAll("circle")
    //     .data(nodes)
    //     .enter().append("circle")
    //     .attr("r", function(d) { return d.radius; })
    //     .style("fill", function(d) { return d.cluster.color; })
    // // Prevent collisions between nodes
    // var forceCollide = d3.forceCollide()
    //     .radius(function(d) { return d.radius + 2; });
    // // Force-directed layout
    // var simulation = d3.forceSimulation(nodes)
    //     .force("collide", forceCollide)
    //     .force("cluster", forceCluster)
    //     .on("tick", tick);
    // // Update frame of animation: redraw in the new position in new color with each tick
    // function tick() {
    //   circle
    //       .attr("cx", function(d) { return d.x; })
    //       .attr("cy", function(d) { return d.y; })
    //       .style("fill", function(d) { return d.cluster.color; });
    //   var recognize = svg.append('text')
    //     .attr('transform', 'translate(225, 630)')
    //     .style('text-anchor', 'middle')
    //     .style('fill', 'black')
    //     .attr('dy', '-2.5em')
    //     .style('font-size', 20)
    //     .style('font-family',"garamond")
    //     .text('Recognized');
    //   var reject = svg.append('text')
    //       .attr('transform', 'translate(525, 630)')
    //       .style('text-anchor', 'middle')
    //       .style('fill', 'black')
    //       .attr('dy', '-2.5em')
    //       .style('font-size', 20)
    //       .style('font-family',"garamond")
    //       .text('Rejected');
    //   var other = svg.append('text')
    //       .attr('transform', 'translate(725,  630)')
    //       .style('text-anchor', 'middle')
    //       .style('fill', 'black')
    //       .attr('dy', '-2.5em')
    //       .style('font-size', 20)
    //       .style('font-family',"garamond")
    //       .text('Other outcome');
    //   var ast = svg.append('text')
    //       .attr('transform', 'translate(' + width/2 + ', 675)')
    //       .style('text-anchor', 'middle')
    //       .style('fill', 'black')
    //       .attr('dy', '-2.5em')
    //       .style('font-size', 15)
    //       .style('font-family',"garamond")
    //       .text('* Each dot represents 1000 asylum seekers');
    // }
    // // Change the x, y velocity for each node
    // function forceCluster(alpha) {
    //   for (var i = 0;  i < nodes.length; ++i) {
    //     var node = nodes[i];
    //     node.vx -= (node.x - node.cluster.x) * alpha;
    //     node.vy -= (node.y - node.cluster.y) * alpha;
    //   }
    // }
    // var pending = nodes.slice(); // Copu to pop since pending will be the ones not selected to move
    // // Classify each node probablistically
    // 

    });
  
  </script>