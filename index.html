<!DOCTYPE html>
<meta charset="utf-8">
<title>Visualization of Iraqi Asylum Seekers</title>
<link rel="stylesheet" type="text/css" href="styles.css"/>
<head>
    <style>

    </style>
</head>

<body>
    <div id="title">
        <h1>Iraqi Asylum Seekers: Where Are They Going?</h1>
    </div>
    <div id="sub-title">
        <h2>Shifting narrative here</h2>
    </div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    // code based on various internet sources, including:
    // https://flowingdata.com/2016/08/23/make-a-moving-bubbles-chart-to-show-clustering-and-distributions/
    // https://bl.ocks.org/pbogden/854425acb57b4e5a4fdf4242c068a127

    // Global vars
    var margin = { top: 30, right: 10, bottom: 10, left: 400 },
        width = 800,
        height = 800;

    var radius = 2.5;
    var center = {
        x: width /2,
        y: height /2
    };

    var destinationClusterRingRadius = 250;
    var classificationOffset = 125;
    var resultoffset = 12;

    // Create svg
    var svg = d3.select("body").append("svg")
        .attr("width", width) 
        .attr("height", height) 
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .append("g");

    // summertime palette
    var results = {
        "recognized": { x: 0, y: 0, color: "#008744" },
        "rejected": { x: 0, y: 0, color: "#d62d20" },
        "other": { x: 0, y: 0, color: "#ffa700" }
    };

    // Create rings around the center with angles -> radians -> coordinates
    var destinationClusters = {
        "Sweden": { theta: - 150 - 30, color: "#005b96", recogtheta: - 150 - 30 - resultoffset, rejecttheta: - 150 - 30, othertheta: - 150 - 30 + resultoffset },
        "Germany": { theta: -150 + 30, color: "#005b96", recogtheta: - 150 + 30 - resultoffset, rejecttheta: - 150 + 30, othertheta: - 150 + 30 + resultoffset },
        "Jordan": { theta: - 30 - 30, color: "#005b96", recogtheta: - 30 - 30 - resultoffset, rejecttheta: - 30 - 30, othertheta: - 30 - 30 + resultoffset },
        "Turkey": { theta: - 30 + 30, color: "#005b96", recogtheta: - 30 + 30 - resultoffset, rejecttheta: - 30 + 30, othertheta: - 30 + 30 + resultoffset },
        "US": { theta: 90 + 40, color: "#005b96", recogtheta: 90 + 40 - resultoffset, rejecttheta: 90 + 40, othertheta: 90 + 40 + resultoffset },
        "Canada": { theta: 90 - 40, color: "#005b96", recogtheta: 90 - 40 - resultoffset, rejecttheta: 90 - 40, othertheta: 90 - 40 + resultoffset },
        "World-Elsewhere": { theta: 90, color: "#005b96", recogtheta: 90 - resultoffset, rejecttheta: 90, othertheta: 90 + resultoffset }
    };

    // Create labels
    var seekerText = createText("", center.x, center.y - 15, 20);
    createText('*Each dot represents 1000 people', width/5, height, 10);
    createText('**Data source: UNHCR Population Statistics', width/5, height + 10, 10);

    var circleLegendRecog = svg.append("circle")
                    .attr("r", radius+2)
                    .style("fill", results.recognized.color)
                    .attr("transform", "translate(" + ((width/5)*4) + "," + (height - 55) + ")")
                    .append("g");
    createText('= Recognized', ((width/5)*4) + 40, height - 55 + 28, 10);

    var circleLegendReject = svg.append("circle")
                .attr("r", radius+2)
                .style("fill", results.rejected.color)
                .attr("transform", "translate(" + ((width/5)*4) + "," + (height - 40) + ")")
                .append("g");
    createText('= Rejected', ((width/5)*4) + 33, height - 55 + 42, 10);

    var circleLegendOther = svg.append("circle")
                .attr("r", radius+2)
                .style("fill", results.other.color)
                .attr("transform", "translate(" + ((width/5)*4) + "," + (height - 25) + ")")
                .append("g");
    createText('= Other Outcome', ((width/5)*4) + 47, height + 3, 10);

    Object.keys(destinationClusters).forEach(function (key) {
        var cluster = destinationClusters[key];
        cluster.x = convertCoordX(destinationClusterRingRadius, cluster.theta);
        cluster.y = convertCoordY(destinationClusterRingRadius, cluster.theta);
        // Create labels
        createText(key, cluster.x, cluster.y - 15, 15);
        // createText('Recognized', convertCoordX(destinationClusterRingRadius + classificationOffset, cluster.recogtheta), convertCoordY(destinationClusterRingRadius + classificationOffset, cluster.recogtheta), 10);
        // createText('Rejected', convertCoordX(destinationClusterRingRadius + classificationOffset, cluster.rejecttheta), convertCoordY(destinationClusterRingRadius + classificationOffset, cluster.rejecttheta), 10);
        // createText('Other Outcome', convertCoordX(destinationClusterRingRadius + classificationOffset, cluster.othertheta), convertCoordY(destinationClusterRingRadius + classificationOffset, cluster.othertheta), 10);
    });
    // console.log(destinationClusters)

    // Preclassify where each node is to go
    function classify(id, destinationClusters) {
        var recognized = destinationClusters.recognized;
        var rejected = destinationClusters.rejected;
        var other = destinationClusters.other;

        if (id <= recognized) {
            return 'recognized';
        } else if (id > recognized && id <= recognized + rejected) {
            return 'rejected';
        } else if (id > recognized + rejected && id <= recognized + rejected + other) {
            return 'other';
        }
    }

    // Vars to build
    var nodes = [];
    var centerSeekers = [];
    var pendings = [];
    var simulation;
    var circle;

    // Master function
    run(['irq_13_js.json', 'irq_14_js.json', 'irq_15_js.json', 'irq_16_js.json']);

    function run(filenames) {

        addData(filenames.shift());

        function addData(filename) {
            // if (simulation) simulation.stop();
            d3.json(filename, function (error, data) {
            var dataset;
            if (error) {
                console.log(error);
                } else {
                    dataset = data;
                    //console.log(data);
                }

                seekerText.text('Asylum Seekers in 20' + filename.substring(4,6));

                // Create nodes based on the dataset
                dataset.forEach(function (d) {
                    var destinationCluster = destinationClusters[d.Destination];

                    // Calculate number of nodes for each classification of the cluster.
                    destinationCluster.total = Math.round(d.Total_apps / 1000);
                    destinationCluster.recognized = Math.round(d.Recognized / 1000);
                    destinationCluster.rejected = Math.round(d.Rejected / 1000);
                    destinationCluster.other = Math.round(d.Other / 1000);

                    // Create nodes for this destination
                    d3.range(destinationCluster.total).map(function (id) {
                        var node = {
                            id: d.Destination + id,
                            // Randomize distribution around the center 
                            x: center.x,
                            y: center.y,
                            radius: radius,
                            destinationCluster: destinationCluster,
                            // Classify the nodes in this destination
                            classification: classify(id, destinationCluster),
                            color: "#283747"
                        };
                        centerSeekers.push(node);
                    });   
                }); 

                // So that the nodes move randomly  
                centerSeekers = shuffle(centerSeekers);
                nodes = nodes.concat(centerSeekers);
                //console.log(centerSeekers)
                //console.log(nodes)

                if (circle) {
                    circle.remove();
                }

                // Add the nodes
                circle = svg.selectAll("circle")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("r", function (d) {
                        return d.radius;
                    })
                    .attr("cx", function (d) {
                        return d.x;
                    })
                    .attr("cy", function (d) {
                        return d.y;
                    })
                    .style("fill", function (d) {
                        return d.color;
                    });

                // Force-directed layout
                simulation = d3.forceSimulation(nodes)
                    .force("collide", forceCollide)
                    .force("cluster", forceCluster)
                    .on("tick", tick)
                    .alpha(0.015);

                setTimeout(goToDestination, 1000);

            });
        } //addData ends here

        // Prevent collisions between nodes
        var forceCollide = d3.forceCollide()
            .radius(function (d) {
                return d.radius + 1;
            });

        // Change the x, y velocity for each node
        function forceCluster(alpha) {
            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i];
                var target = node.target || center;
                node.vx -= (node.x - target.x) * alpha;
                node.vy -= (node.y - target.y) * alpha;
            }
        }

        // Update frame of animation: redraw in the new position in new color with each tick
        function tick() {
            if (!circle) return;
            circle
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                })
                .style("fill", function (d) {
                    return d.color;
                });
            }

        var updateInterval = 20;

        function goToDestination() {
            if (centerSeekers.length > 0) {
                var node = centerSeekers.pop();
                node.color = node.destinationCluster.color;                
                node.target = node.destinationCluster;
                pendings.push(node); 

                simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
                setTimeout(goToDestination, updateInterval);  
            } else {
                var keepAlive = setInterval(function () {
                    simulation.alpha(0.015);
                }, updateInterval);

                setTimeout(function () {
                    clearInterval(keepAlive);
                    classifyPendings();
                }, 2000);
            }
        }

        // Next level of classification into results groups
        function classifyPendings() {
            if (pendings.length > 0) {
                var node = pendings.pop();
                var classification = results[node.classification];

                if (classification) {
                    node.color = results[node.classification].color;

                    // Clone the current target
                    node.target = { x: node.target.x, y: node.target.y };

                    // Assign new locations relative to the current destination's center depending on the classification.
                    if (node.classification === 'recognized') {
                        node.target = {x: convertCoordX(destinationClusterRingRadius + classificationOffset, node.destinationCluster.recogtheta),
                                    y: convertCoordY(destinationClusterRingRadius + classificationOffset, node.destinationCluster.recogtheta)}
                    } else if (node.classification === 'rejected') {
                        node.target = {x: convertCoordX(destinationClusterRingRadius + classificationOffset, node.destinationCluster.rejecttheta),
                                    y: convertCoordY(destinationClusterRingRadius + classificationOffset, node.destinationCluster.rejecttheta)}
                    } else {
                        node.target = {x: convertCoordX(destinationClusterRingRadius + classificationOffset, node.destinationCluster.othertheta),
                                    y: convertCoordY(destinationClusterRingRadius + classificationOffset, node.destinationCluster.othertheta)}
                    }
                }

                simulation.alpha(0.015);  // Keep the alpha constant instead of slowing down
                setTimeout(classifyPendings, updateInterval);  
            } else {
                var keepAlive = setInterval(function () {
                    simulation.alpha(0.015);
                }, updateInterval);

                // Keep the nodes moving for another 5 seconds
                setTimeout(function () {
                    clearInterval(keepAlive);
                    if (filenames.length > 0) {
                        addData(filenames.shift());
                    } else {
                        simulation.stop();
                    }
                }, 5000);
            }
        }
    } //run ends here

    function convertCoordX(ringradius, theta) {
        return ringradius * Math.cos((Math.PI / 180) * theta) + center.x;
    }

    function convertCoordY(ringradius, theta) {
        return ringradius * Math.sin((Math.PI / 180) * theta) + center.y;
    }

    // function from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
        return array;
    }

    function createText(text, x, y, fs) {
        var translate = 'translate(' + x + ', ' + y + ')';
        var text = svg.append('text')
            .attr('transform', translate)
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .attr('dy', '-2.5em')
            .style('font-size', fs)
            .style('font-family', "garamond")
            .style('font-weight', 'bold')
            .text(text);
        return text;
    }


</script>
